# 파이썬의 기본 자료구조

정수, 실수, 문자열은 그 자체만으로 훌륭한 데이터지만 세상의 많은 것들은 그리 단순히 처리되지 않습니다. 파이썬에서는 기본 데이터 타입을 엮어서 만든 4개의 기본 자료구조를 제공합니다. 

우리의 역할은 이러한 자료구조를 엮어서 복잡하고 탄탄한 형태로 재탄생시키는 것 입니다.



## 리스트

문자열은 문자의 시퀀스(순서가 있는 나열)라면, 리스트는 모든 것의 시퀀스입니다. 리스트는 변경가능(mutable)하므로 항목을 자유롭게 할당, 수정, 삭제할 수 있습니다. 

#### 리스트 생성

리스트는 아래와 같은 형태로 생성할 수 있습니다.

```python
>>> empty = []
>>> empty
[]
>>> empty2 = list()
>>> empty2
[]
```

다른 요소로 채워진 채로 생성할 수 도, split과 같은 함수로 생성할 수 도 있습니다.

```python
>>> count_down = [3, 2, 1]
>>> count_down
[3, 2, 1]
>>> weekdays = 'Monday Tuesday Wednesday Thursday Friday'.split(' ')
>>> weekdays
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
>>> cat = 'cat'
>>> list(cat)
['c', 'a', 't']
```



#### offset과 slice

문자열과 마찮가지로 리스트는 시퀀스입니다. 따라서 offset으로 하던 일을 동일하게 수행할 수 있습니다.

```python
>>> import string
>>> alpha = list(string.ascii_lowercase)
>>> alpha
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
>>> alpha[5]
'f'
>>> alpha[5:10]
['f', 'g', 'h', 'i', 'j']
```

차이가 있다면 리스트는 offset을 통해 요소를 수정할 수 있습으며 범위를 넘는 인덱싱은 에러를 출력합니다.



#### sort와 sorted

* sort( )는 리스트 자체를 내부적으로 정렬합니다.
* sorted( )는 리스트의 정렬된 복사본을 반환합니다.

리스트의 항목이 숫자인 경우, 기본적으로 오름차순으로 정렬하며, 문자열의 경우 알파멧순으로 정렬합니다.

```python
>>> fruit = ['cherry', 'banana', 'apple']
>>> sorted(fruit)
['apple', 'banana', 'cherry']
>>> fruit.sort()
>>> fruit
['apple', 'banana', 'cherry']
```

반대로 정렬하고 싶다면 인자에 ```reverse=True``` 를 추가합니다.

만약 특정 규칙으로 정렬하고 싶다면 인자에 ```key=function``` 을 추가합니다. 이 때 function은 하나의 값을 인자로 받고 비교할 값을 반환해야 합니다.

function은 일반함수이거나 익명함수(lambda)일 수 있습니다.

```python
>>>  # 문자열의 offset 1을 기준으로 정렬합니다.
>>> sorted(fruit, key=lambda x: x[1])
['banana', 'cherry', 'apple']
```



#### 할당, 복사, 깊은 복사

한 리스트를 변수 두 곳에 할당하다면, 한 리스트만 변경해도 다른 리스트도 따라서 변경됩니다. 엄밀하게 따지면 두 변수가 동일한 리스트를 참조하기 때문입니다.

```python
>>> list_1 = [1, 2, 3]
>>> list_2 = list_1
>>> list_1[0] = '_'
>>> list_1
['_', 2, 3]
>>> list_2
['_', 2, 3]
>>> id(list_1) == id(list_2)
True
```



리스트의 메소드, copy를 사용하면 리스트를 복사하여 붙여넣게 됩니다.

```python
>>> list_1 [1, 2, 3]
>>> list_2 = list_1.copy()
>>> list_1[0] = '_'
>>> list_1
['_', 2, 3]
>>> list_2
[1, 2, 3]
>>> id(list_1) == id(list_2)
False
```



하지만, 이는 겉 껍데기 즉 리스트만 새로 공간을 할당했을 뿐, 내부 요소는 원래의 값들을 참조하고 있습니다. 그러나 정수는 immutable 객체이기 때문에 요소가 재할당 될 뿐입니다. 만약 리스트의 요소가 또다른 mutable 객체라면 다음과 같은 현상이 발생합니다.

```python
>>> list_1 = [[1, 2], [3, 4]]
>>> list_2 = list_1.copy()
>>> id(list_1) == id(list_2)
False
>>> id(list_1[0]) == id(list_2[0])
True
```



이러한 현상을 방지하기 위해서는 ```import copy``` 를 이용하여 깊은 복사를 수행하면 됩니다. 깊은 복사는 내부적으로 참조하는 객체 하나도 없도록 모두 재할당합니다. 사용법은 아래와 같습니다.

```python
>>> # from copy import deepcopy
>>> import copy
>>> list_1 = [[1, 2], [3, 4]]
>>> list_2 = copy.deepcopy(list_1)
>>> id(list_1) == id(list_2)
False
>>> id(list_1[0]) == id(list_2[0])
False
```



파이썬이 얕은 복사, 참조를 활용하는 이유는 다른 상대적 저수준의 언어와 달리 파이썬의 데이터들이 모두 객체이기 때문입니다. 이는 필연적으로 속도의 저하와 더 높은 공간비용을 요구합니다.

만약 메모리 부족등으로 복사가 실패한다면 copy.Error를 raise 하게됩니다. 



#### 그 외

그 외에도 다음과 같은 함수들이 주로 사용됩니다.

- append(element)

  element를 리스트 뒤에 추가합니다.

- extend(list) , +=

  리스트와 새로운 리스트를 병합합니다.

- insert(offset, element)

  offset의 위치에 element를 추가합니다. 범위 밖이라면 append와 동일합니다.

- del

  del은 리스트의 함수가 아니라 파이썬의 내장함수입니다. offset을 통해 항목을 삭제할 수 있습니다.

- remove(element)

  만약 offset을 모른다면 remove 함수를 통해 동일한 값을 삭제할 수 있습니다.

- pop(0), pop(-1)

  offset을 통해 삭제하며 요소를 반환할 수 있습니다. default는 -1로 리스트를 stack처럼 사용할 수 있습니다. pop(0)으로 사용한다면 queue처럼 사용할 수 있습니다.

- index(element)

  element를 찾아 offset을 반환합니다.

- len(list)

  리스트의 길이를 반환합니다.

## 튜플

튜플은 리스트와 마찮가지로 모든 것의 시퀀스입니다. 그러나 리스트와 다르게 튜플은 immutable 입니다. 이 말은 튜플을 정의한 후에는 추가, 삭제, 수정을 할 수 없음을 의미합니다. 



#### 튜플의 생성

튜플은 리스트와 다르게 ```[ ]```가 이닌 ```( )```로 생성합니다. 혹은 ```tuple( )```과 같이 명시적으로 생성할 수 있습니다.  그러나, ```(1)```과 같이 내부 요소가 하나 뿐이라면 연산자로서 인식하기 때문에 ```(1, )```와 같이 사용해야합니다.

```python
>>> empty = ()
>>> empty
()
>>> one = (1)
>>> one
1
>>> one = (1, )
>>> one
(1, )
>>> one[0] = 2
TypeError: 'tuple' object does not support item assignment
```



튜플은 내부 요소가 불변이기 때문에 리스트에 비해서 메모리를 더 적게 사용합니다. 따라서 상수 목록을 저장할 때 유리합니다. 그러나 튜플은 파이썬 문법 내부적으로 다양하게 활용됩니다.



#### 튜플 언패킹

C언어 등에서 두 변수의 값을 교환하기 위해서는 다음과 같은 방법을 사용합니다.

```C
int main(void)
{
	int a = 1;
    int b = 2;
    int t;
    printf("a: %d, b: %d\n", a, b); // a: 1, b: 2
    
    // 방법 1, 임시변수를 이용한 교환
    t = a;
    a = b;
    b = t;
    printf("a: %d, b: %d\n", a, b); // a: 2, b: 1
    
    // 방법 2, XOR 연산을 이용한 교환
    a ^= b;
    b ^= a;
    a ^= b;
    printf("a: %d, b: %d\n", a, b); // a: 1, b: 2
    return 0;
}
```



파이썬에서는 아래와 같은 방법이 가능합니다.

```python
>>> a = 1
>>> b = 2
>>> print('a: {}, b: {}'.format(a, b))
a: 1, b: 2
>>> a, b = b, a
>>> print('a: {}, b: {}'.format(a, b))
a: 2, b: 1
```



이는 동시에 여러 값이 할당될 때, 해당 영역을 튜플로 취급하기 때문에 가능합니다.  어떤 값을 입력받을 때, 각각의 변수 들어가는 것 또한 튜플 언패킹에 해당됩니다.

```python
>>> values = input().split(' ')
4 5
>>> values
['4', '5']
>>> a, b = values
>>> a
'4'
>>> b
'5'
```

또한 함수의 인자들은 튜플로서 전달됩니다.



## 딕셔너리

딕셔너리(dictionary)는 리스트와 유사합니다. 그러나 순서를 따지지 않으며, 0, 1과 같은 수로 offset으로 항목을 다루지 않고 'key'를 이용하여 호출할 수 있습니다.

이러한 'key'는 불변하는 파이썬의 어떤 타입도 될 수 있습니다. (일반적으로는 문자열이 사용됩니다.) hash, hashmap, associative array라고도 불립니다.



#### 딕셔너리 생성

딕셔너리는 { } 안의 키:값 쌍을 통해서 생성할 수 있습니다. 

```python
>>> empty = {}
>>> empty
{}
>>> data = {
    'alpha':tuple('abcdefghijklmnopqrstuvwxyz'),
    'number':tuple('0123456789')
}
>>> data['number']
('0', '1', '2', '3', '4', '5', '6', '7', '8', '9')
```



두 값으로 이루어진 시퀀스는 딕셔너리로 변환할 수 있습니다. 단, key는 중복되면 안됩니다.

```python
>>>  # (위도, 경도)와 장소명으로 이루어진 리스트
>>> spot = [
    [((28, 50, 58.62), (138, 44, 52.01)), '태풍'],
    [((35, 48, 04.83), (128,  5, 56.80)), '해인사'],
    [((37, 31, 14.51), (126, 56, 23.50)), '63빌딩'],
    [((37, 35, 08.29), (126, 58, 29.48)), '청와대'],
]
>>> dict_spot = dict(spot)
>>> dict_spot
{((28, 50, 58.62), (138, 44, 52.01)): '태풍',
 ((35, 48, 4.83), (128, 5, 56.8)): '해인사',
 ((37, 31, 14.51), (126, 56, 23.5)): '63빌딩',
 ((37, 35, 8.29), (126, 58, 29.48)): '청와대'}
```





## 셋

